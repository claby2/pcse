(* This grammar is only valid for _tokens_, not _the raw code_ (i.e. it ignores whitespace, etc.) *)
(* Any CAPITALIZED variable is a special token *)

program = { topstmt };
(* { something } can be repeated zero times *)
block = { stmt };

topstmt = stmt | 
		DECLARE, identifier, COLON, type |
		CONSTANT, identifier, =, expr
		PROCEDURE, identifier, [ LEFT_PAR, paramlist, RIGHT_PAR ], block, ENDPROCEDURE |
		FUNCTION, identifier [ LEFT_PAR, paramlist, RIGHT_PAR ], RETURNS, type, block, ENDFUNCTION
;
stmt = 	identifier, ASSIGN, expr |
		INPUT, identifier |
		OUTPUT, exprlist |
		IF, expr, THEN, block, [ ELSE, block ], ENDIF |
		CASE, OF, identifier, { expr, COLON, block }, [ OTHERWISE, block ], ENDCASE |
		FOR, identifier, ASSIGN, expr, TO, expr, [ STEP, expr ], block, NEXT
		REPEAT, block, UNTIL, expr |
		WHILE, expr, DO, block, ENDWHILE | 
		CALL, identifier, [ LEFT_PAR, paramlist, RIGHT_PAR ]
;

exprlist = { expr, COMMA }, expr;
paramlist = [ { param, COMMA }, param ];
param = [ BYREF ], identifier, COLON, type;

(* top level expr *)
expr = bin_expr0;

(* binary expr <precedence level> *)
bin_expr0 = bin_expr1 { OR bin_expr1 };
bin_expr1 = bin_expr2 { AND bin_expr2 };
bin_expr2 = bin_expr3 { ( EQ | GT | LT | GT_EQ | LT_EQ | LT_GT ) bin_expr3 };
bin_expr3 = bin_expr4 { ( PLUS | MINUS ) bin_expr4 };
bin_expr4 = unary_expr { ( STAR | SLASH | MOD | DIV ) unary_expr };

unary_expr = [ NOT | MINUS ] primary;
primary = REAL_C | INT_C | STR_C | TRUE | FALSE | identifier |
		LEFT_PAR expr RIGHT_PAR;

type = [ T_ARRAY, LEFT_SQ, expr, COLON, expr, RIGHT_SQ ] (T_INTEGER | T_REAL | T_CHAR | T_STRING | T_BOOLEAN | T_DATE);
identifier = ? IDENTIFIER ?;
